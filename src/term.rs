use std::io::Write;
use std::sync::{Arc, Mutex};
use termcolor::{Color, ColorChoice, ColorSpec, StandardStream, WriteColor};

pub struct ColorTerm {
    stdout: Mutex<StandardStream>,
    color_spec: Mutex<ColorSpec>,
}

impl ColorTerm {
    fn new() -> ColorTerm {
        ColorTerm {
            stdout: Mutex::new(StandardStream::stdout(ColorChoice::Always)),
            color_spec: Mutex::new(ColorSpec::new()),
        }
    }

    pub fn cout<T: AsRef<str>>(&self, text: T, color_spec: &ColorSpec) {
        let mut stdout = self.stdout.lock().unwrap();
        stdout.set_color(color_spec).expect("Set color fail");
        write!(stdout, "{}", text.as_ref()).expect("Write color output failed");
        stdout.set_color(&*self.color_spec.lock().unwrap()).expect(
            "Set color fail",
        );
    }

    pub fn out<T: AsRef<str>>(&self, text: T) {
        write!(self.stdout.lock().unwrap(), "{}", text.as_ref()).expect("Write color output failed");
    }

    pub fn set_default_color(&self, fg: Option<Option<Color>>, bg: Option<Option<Color>>, bold: Option<bool>) {
        let mut spec = self.color_spec.lock().unwrap();
        if let Some(fg) = fg {
            spec.set_fg(fg);
        }
        if let Some(bg) = bg {
            spec.set_bg(bg);
        }
        if let Some(bold) = bold {
            spec.set_bold(bold);
        }
        self.stdout.lock().unwrap().set_color(&*spec).expect(
            "set color fail",
        );
    }
}

lazy_static! {
    pub static ref TERM: Arc<ColorTerm> = Arc::new(ColorTerm::new());
}
